var stream_to_lines = require('./../stream_to_lines');
var fs = require('fs');
var child_process = require('child_process');
var path = require('path');
var util = require('util');
var _ = require('underscore');

var RELEASE_NOTES_PATH = path.resolve(__dirname, 'release_notes.txt');
var RELEASE_RE = /^(.*), Version (.+) \((.*)\)(, (.*))?$/
var BULLET_RE = /^\* ([\w]*): (.*)$/

var _DEBUG = false;

var _summary = null;

function _i(n) {
    n = n.replace(/^0/, '');
    if (n == '') return 0
    return parseInt(n);
}
module.exports = {

    parse_vesion:function (v) {
        if (!_.isString(v)) {
            throw new Error('parse_version requires string');
        }
        var v_data = {
            major:0,
            minor:0,
            dot:0,
            milestone:''
        }
        var vd = v.split('.');
        if (vd.length) {
            v_data.major = _i(vd.shift());
        }
        if (vd.length) {
            v_data.minor = _i(vd.shift());
        }
        if (vd.length) {
            v_data.dot = _i(vd.shift());
        }
        if (vd.length) {
            v_data.milestone = vd.join('.');
        }

        return v_data;
    },

    parse_date:function (date_string) {
        if (!_.isString(date_string)) {
            throw new Error('bad input for parse_date: ' + util.inspect(date_string));
        }
        var parts = date_string.split('.');
        if (_DEBUG) console.log('date_parts: %s', util.inspect(parts));

        return {
            year:_i(parts[0]),
            month:_i(parts[1]),
            date:_i(parts[2])
        };
    },

    line_data:function (line) {

        if (_DEBUG) {
            console.log('testing %s', line);
        }
        var j = false;

        if (RELEASE_RE.test(line)) {
            var r = RELEASE_RE.exec(line);
            if (_DEBUG) {
                console.log('line regex output: %s', util.inspect(r));
            }
            var data = {
                CLASS:'release',
                date:(r[1]),
                version:r[2],
                version_state:r[3],
                hash:r[4]
            };

            _.extend(data, module.exports.parse_date(data.date));

            data.version_numbers = module.exports.parse_vesion(data.version);
            return data;

        } else if (BULLET_RE.test(line)) {
            var r = BULLET_RE.exec(line);
            return {
                CLASS:'bullet',
                subject:r[1],
                notes:r[2]
            }


        } else {
            return false;
        }
    },

    read_config:function (callback) {

        var releases = {releases:[]};
        var release = false;

        function _on_done() {
            callback(null, releases);
        }

        function _on_err(err) {
            callback(err);
        }

        function _on_line(line) {
            var data = module.exports.line_data(line);
            if (data) {
                switch (data.CLASS) {
                    case 'release':
                        delete data.CLASS;
                        if (release) {
                            releases.releases.push(release);
                        }
                        ;
                        release = {
                            release:data,
                            notes:[]
                        }
                        break;

                    case 'bullet': // note - assuming releases come before bullets;
                        if (!release) {
                            throw new Error('bullet %s found before a release', line);
                        }
                        delete data.CLASS;
                        release.notes.push(data);
                        break;

                    default:
                    // don't care about blank lines
                }
            }
        }

        stream_to_lines(RELEASE_NOTES_PATH, _on_line, _on_err, _on_done);


    },

    summarize:function () {
        if (!_summary) {
            var release_notes = fs.readFileSync(path.resolve(__dirname, 'release_notes.json'), 'utf8');
            var j = JSON.parse(release_notes);

            _summary = _.map(j.releases, function (release) {
                var time_date = new Date(release.year, release.month, release.date);
                var time = time_date.getTime();
                _summary = {
                    version:release.version,
                    version_numbers:_.clone(release.version_numbers),
                    date:{
                        year:release.year,
                        month:release.month,
                        date:release.date
                    },
                    time:time
                }


            });
        }
        return _.map(_summary, _.clone);
    },

    relevance:function (time) {
        if (!_.isNumber(time)){
            throw new Error('time must be a number for relevance');
        }

        var releases = module.exports.summarize();
        var rr = _.filterBy(releases, function(release){
            return release.time >= time;
        })

        rr == _.sortBy(rr, function(release){
            return release.time;
        });

        var relevance_penalty = 0
        var last_release = null;

        rr.forEach(function(r){
            if (last_release){
                if (last_release.version_numbers.major == r.version_numbers.major){
                    if(last_release.version_numbers.minor == r.version_numbers.minor){
                        relevance_penalty += 0.5
                    } else {
                        relevance_penalty += 0.05;
                    }
                } else {
                    relevance_penalty += 10;
                }
            }

            last_release = r;
        })

        return 3 - relevance_penalty;

    }
}
