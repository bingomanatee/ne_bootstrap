{"__v":21,"_id":"nuby_express:action_script","author":"bingomanatee","content":"The script component of an action is a file called `\"action.js\"` in the root of an action folder. It can also be named after the containing action -- i.e., `\"/actions/list_users/list_users_action.js\"`.\n\nAction scripts are designed to respond to either one [[method:Method]] or several methods.* If your [[action_config:Action's configuration file]]'s method property is \"*\", as in \n\n``` javascript\n{\n  \"method\": \"*\",\n  \"get_route\": \"/article/:id\",\n  \"post_route\": \"/article/\",\n  \"put_route\": \"/article/:id\"\n}\n```\nyour action is multi-method; otherwise, it is single method:\n``` json\n{\n    \"method\": \"get\",\n    \"route\": \"/articles\"\n}\n```\n\n## single method action flow\n\nThe flow of a single action flows through three or four methods. `on_validate`, `on_input`, `on_process`, and optionally, `on_output`.\n\nEach of those actions takes a [[req_state:Req_State]](Short for Request State) parameter. This parameter holds the classic req and res objects of an Express method, plus some utility methods, and the req_params collection of request parameters.\n\n### on_validate(rs)\n\nthis method is where you validate the users' credentials and ability to access the action, as well as the existence of key properties in the rs.req_params collection. \n\nFrom this method you either [[error_handling:emit an error]] or pass control to the action's `on_input` handler. \n\n### on_input(rs)\n\nthis method is where you extract any information you need from databases/data repositories, the file system, or any other external resources, including web services or network resources. The result of these data requests are passed as external properties to the `on_process` handler, unless there are errors which are emitted. \n\n### on_process(rs [, input ...])\n\nThis method is where you push changes out to the database, file system or other repositories. \n\nIf you encounter an error, [[error_handling:emit an error]]. \n\nFor REST actions this can be the end of the chain. Push any data you wish out through `rs.send({object})`. \n\nIf you are using the server-side [[views:templating system]], you can pass control to it by calling `on_output(rs, object)`. \n\n### on_output (rs, input)\n\nThis method is added to each action at run time; don't actually write an on_output handler unless you want better control over selection of the server side template. Note that unlike `on_process` which can have as many parameters as you want, on_putput takes a single property and that property must be a javascript [[objects:Object]]\n\n## Multi-method action flow\n\nMulti-request methods must have a set of methods that mirror the above methods, except with REST method names inserted in them: \n\n### GET methods:\n\n* `on_get_validate(rs)\n* `on_get_input(rs)\n* `on_get_process(rs [, input args])\n\n### POST methods: \n\n* `on_post_validate(rs)\n* `on_post_input(rs)\n* `on_post_process(rs [, input args])\n\n### PUT methods:\n\n* `on_put_validate(rs)\n* `on_put_input(rs)\n* `on_put_process(rs [, input args])\n\n### DELETE methods:\n\n* `on_delete_validate(rs)\n* `on_delete_input(rs)\n* `on_delete_process(rs [, input args])\n\nsee [[sending_rest_data_from_forms]] for tips on sending all the rest methods from the client.\n\n-------\n<small>* This is distinct from responding to multiple urls]] - an action that responds to `GET /articles` and `GET: /articles/:_id` is still a single-method action because both urls are GET responses, and both urls will be handled by the same method. Distinguishing between which url is being responded to is up to the developer by examining `rs.req.url`.","creator":"bingomanatee","name":"action_script","scope":"nuby_express","summary":"The server side response to a URL endpoint -- where the action is!","title":"Action script file","write_date":"2012-10-21T04:50:31.157Z","scope_root":false,"deleted":false}