{"__v":21,"_id":"nuby_express:framework_launch_sequence","author":"bingomanatee","content":"To better understand the way Nuby Express operates, it is good to understand what execution happens in which order. \n\n## The Bootstrap Script\n\nIn order to initialize a Nuby Express application, you have to have a Bootstrap Script. The script below is the standard one I use; it allows for the insertion of a few key parameters into the load cycle to enable integration testing; specifically the ability to run on a different port, so you can start and shut down any number of instances of the application during the execution of multiple tests.\n\nIt also has code for configuring mongodb, including the ability to change the name of the base DB, for integration testing. \n\n``` javascript\n\nvar NE = require('nuby-express');\nvar util  = require('util');\n\nvar _DEBUG = true;\n\nmodule.exports = function (config, callback) {\n```\nHere is where the framework singleton is created. Note it needs to be \"pointed\" at the application directory. \n\n``` javascript\n\n    var frame = new NE.Framework();\n\n    NE.log.set_log_file(__dirname + '/logs/nuby_express.log', {reset: true})\n    frame.start_load(_on_load, __dirname + \"/app\");\n\n```\n\nThis is the callback that executes after the structure of the application has been loaded. Note that you have to manually call start_server; this gives you an opportunity to do any operations for which the ability to introspect over the component/controller/resource manifest of the Framework is useful. \n\n``` javascript\n\n    function _on_load() {\n        if (_DEBUG) console.log('framework loaded');\n        if (config){\n            if(config.mongoose){\n                frame.config.mongoose.db = config.mongoose.db;\n            }\n        }\n        frame.start_server(function () {\n            var port = frame.config.server.port;\n            if (config) {\n                if (config.port) {\n                    port = config.port;\n                }\n\n                if(config.mongoose){\n                    frame.config.mongoose.db = config.mongoose.db;\n                }\n            }\n\n            console.log('listening to port %s', port);\n            frame.server().listen(port);\n\n            if (callback) {\n                callback();\n            }\n        });\n    }\n\n    return frame;\n};\n\n```\n\n## Application Loading \n\nApplications are loaded by calling `framework.start_load(callback, 'path_to_app_dir')`. This initializes a scan of the application directory for resources, components, controllers, and a `public` folder for shared static resources.*\n\n## Server Startup\n\nInside the callback you pass to `start_load` you must manually trigger framework.start_load(). \n\nThere are several sub-stages to server startup. \n\n### Mixin Execution\n\nMixins are a specific brand of resources that are designed to modify the Framework. If you have file or folder types that you want to scan for in the current application structure -- such as scanning for layout directories, by the [[layout_component:Layout component]] mixin -- creating a mixin that re-explores the application is the best way to do this. \n\n### Express Helper initialization. \n\nExpress helpers allow you to directly access the Express Server property of the framework to add middleware to it. Here is one example of this - the express_helper that enables sessions: \n\n``` javascript\nvar ne = require('nuby-express');\n\nmodule.exports = {\n    start_server:function (server, frame, cb) {\n        var session_secret = frame.get_config('session_secret', 'Alfred E Neuman')\n        var session_config = { secret: session_secret };\n\n        if (frame.config.session) {\n            session_config = frame.config.session;\n        }\n\n        server.use(\n            ne.deps.express.cookieParser(session_config));\n        server.use(\n            ne.deps.express.session(session_config));\n        cb();\n    }\n}\n\n```\n\n## Status at end of server startup\n\nAt this point the following should be true:\n\n* The application is listening to a specific port for web traffic\n* The framework has a full list of all resources from all components in the app directory\n* The framework has a full map of all the controllers, actions, and components in the app directory\n* Each action is now listening to the URL / REST paths listed in its configuration\n* Each action's models collection has a reference to every model resource in the application.\n# Request Response Cycle\n\nEach action at this point is listening to one or more URL/[[method]] combination. \nWhen a request comes in the following execution path is triggered. \n\n## Action Selection\n\nExpress' routing mechanism chooses the action that best matches the request URL. \n\n## Req_State creation\n\nNuby Express creates a new [[req_state:Request State]] (Req_state) object. This object's req_props property is populated from url and body properties. \n\n## Action Execution\n\nThe Req_State is passed to the validation method; either `on_validate(rs)` for single-method actions, or `on_(get|put|post|delete)_validate(rs)` for multi-method actions.  \n\nThe execution inside your application proceeds; Ultimately flow is up to you but the [[actions:Action documentation]] describes \"Best Practices\" for NE actions. \n\nThere are several legitimate ways for execution to progress out of action's execution:\n\n1. Emitting an [[error_handling:error]] from the application. This triggers either a JSON block to be returned, or a redirection to another URL, annotated with a flash message. \n2. Calling the actions' `on_output(rs, input)` method (see below). \n3. Calling `rs.send(input)` which sends a raw JSON block back as a response. \n4. Calling `rs.render(template, input)`; the first argument is a string block of EJS markup. This is in fact what happens when `on_output(rs, input)` is called\n5. Calling `rs.go(path)` to redirect the user to another action/outside URL.\n\nNote that __ONLY ONE__ of these alternatives should occur for any given request. \n\n### Emitting an Error\n\nIf a subprocess returns an error and you wish to emit this error to the user, call `this.emit(type, rs, error|message)` from the action. The [[error_handling:Error Handling]] documentation describes this in detail. \n\n### rs.send(input)\n\ncalling rs.send(input) sends a JSON block to the client as a response. Note: this also occurs if you call `on_output(rs, output)` from an action that does not have a template file. Also note: `send()` avoids the execution of all the view helpers. \n\n### on_output(rs, input)\n\nThe `on_output(rs, input)` method that is included with every action executes the following process:\n\n1. A template for the action is searched for\n2. If the template is found, its contents is passed to `rs.render(template, input)`. (otherwise, `rs.send(input)` is called; see above)\n3. `rs.render(template, input)` passes the input through all the [[view_helpers:View Helpers]], in increasing order of weight. \n4. The input -- as altered by the view_helpers -- is passed through your template\n5. The output of the rendered EJS is passed through any existing layout. This can be better managed through the [[layout_component:Layout component]]. \n\n### rs.render(template, input)\n\nAs from 3. above, except that you must manually load the template file yourself. Useful if you want to switch between more than one template based on request context. \n\n--------\n<small>* Although a public folder is provided for the sake of standard structure, there really is no appropriate content for such a directory. Layouts and Actions both have local repositories for static content that encapsulate such resources much better than a shared folder for static files.</span>","creator":"bingomanatee","name":"framework_launch_sequence","scope":"nuby_express","summary":"The load sequence, and order of operations in a request/response session","title":"framework launch_sequence","write_date":"2012-10-26T16:38:01.436Z","scope_root":false,"deleted":false}